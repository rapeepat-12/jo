<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Incremental Stats Game — BigXeN Unlimited</title>

<style>
  body { background:#111; color:#ddd; font-family:Arial; margin:0; padding:0; }
  .wrap { display:flex; padding:20px; gap:20px; }
  .panel { background:#222; padding:15px; border-radius:6px; width:300px; }
  .section-title { font-size:1.2em; margin-bottom:10px; }
  .stat-row { display:flex; justify-content:space-between; margin-bottom:5px; }
  button { width:100%; margin:5px 0; height:35px; font-size:1em; background:#444;
           color:#fff; border:none; border-radius:4px; cursor:pointer; }
  button:hover { background:#666; }
  #message { height:20px; margin-top:15px; font-size:14px; color:#0f0; }
</style>

</head>
<body>

<div class="wrap">

  <!-- LEFT PANEL: Stats -->
  <div class="panel">
    <div class="section-title">Stats</div>
    <div id="statsBox"></div>
  </div>

  <!-- MIDDLE PANEL: Actions -->
  <div class="panel">
    <div class="section-title">Actions</div>
    <div id="aValue"></div><br>
    <button id="upgradeBtn">Upgrade All</button>
    <div>Upgrade cost: <span id="upgradePrice"></span></div><br>

    <button id="unlockBtn">Unlock Next Stat</button>
    <div>Unlock cost: <span id="unlockCost"></span></div><br>

    <button id="challengeBtn">Start Tier</button>
    <button id="completeBtn">Complete Tier</button>
    <div>Challenge state: <span id="challengeState"></span></div>
    <div>Tier info: <span id="tierInfo"></span></div><br>

    <button id="rebirthBtn">Rebirth</button>
    <div>Rebirths: <span id="rebirthCount"></span></div>
    <div>Rebirth cost: <span id="rebirthCost"></span></div>

    <div id="message"></div>
  </div>

</div>

<script>
/* ================================================================
   BIGXEN — Unlimited Scientific Numbers
   ================================================================ */

function BX(v) {
  if (typeof v === "number") {
    if (!isFinite(v)) return { c: Infinity, e: 0 };
    if (v === 0) return { c: 0, e: 0 };
    const e = Math.floor(Math.log10(Math.abs(v)));
    const c = v / Math.pow(10, e);
    return { c, e };
  }
  return { c: v.c, e: v.e };
}

function BX_norm(a) {
  if (!isFinite(a.c)) return a;
  if (a.c === 0) { a.e = 0; return a; }
  while (Math.abs(a.c) >= 10) { a.c /= 10; a.e++; }
  while (Math.abs(a.c) < 1)   { a.c *= 10; a.e--; }
  return a;
}

function BX_clone(a) { return { c:a.c, e:a.e }; }

function BX_add(a,b) {
  a = BX(a); b = BX(b);
  if (a.c === 0) return BX_clone(b);
  if (b.c === 0) return BX_clone(a);
  const diff = a.e - b.e;
  if (diff > 20) return BX_clone(a);
  if (diff < -20) return BX_clone(b);
  if (diff >= 0) {
    return BX_norm({ c:a.c + b.c / 10**diff, e:a.e });
  } else {
    return BX_norm({ c:a.c/10**(-diff) + b.c, e:b.e });
  }
}

function BX_sub(a,b) {
  return BX_add(a, {c:-b.c, e:b.e});
}

function BX_mul(a,b) {
  a = BX(a); b = BX(b);
  return BX_norm({ c:a.c*b.c, e:a.e+b.e });
}

function BX_mulScalar(a,n) {
  return BX_norm({ c:a.c*n, e:a.e });
}

function BX_pow(a,p) {
  a = BX(a);
  return BX_norm({ c:Math.pow(a.c,p), e:a.e*p });
}

function BX_gte(a,b) {
  return (a.e > b.e) || (a.e === b.e && a.c >= b.c);
}

function BX_zero() { return {c:0,e:0}; }

function BX_toString(a) {
  if (!isFinite(a.c)) return "∞";
  return `${(Math.round(a.c*1000)/1000)}e${a.e}`;
}

/* ================================================================
   STATE
   ================================================================ */

const state = {
  stats:{ a:BX(10) },
  unlocked:["a"],
  allMult:BX(1),
  upgradePrice:BX(100),
  unlockCost:BX(100),

  tiers:[],
  currentTier:0,
  tierActive:false,
  tierDebuffed:false,

  aMultiplierFromTiers:BX(1),
  bMultiplierFromTiers:BX(1),

  rebirths:0,
  rebirthUnlocked:false,
  rebirthFreeAvailable:false,
  rebirthCost:null
};

function initTiers() {
  state.tiers = [];
  let tgt = BX(1e6);
  for (let i=1;i<=15;i++){
    state.tiers.push({ id:i, done:false, target:BX_clone(tgt) });
    tgt = BX_pow(tgt,2);
  }
}
initTiers();

function ensureStats(){
  for(const s of state.unlocked){
    if(!state.stats[s]) state.stats[s]=BX(10);
  }
}

/* Stat label generator */
function statLabel(n){
  let alphabet="abcdefghijklmnopqrstuvwxyz";
  if (n<=26) return alphabet[n-1];
  let out="";
  while(n>0){
    let rem=(n-1)%26;
    out=alphabet[rem]+out;
    n=Math.floor((n-1)/26);
  }
  return out;
}

/* ================================================================
   TICK
   ================================================================ */

function doTick(){
  ensureStats();

  const deltas={};
  for(const s of state.unlocked) deltas[s]=BX_zero();

  /* Base growth */
  for(const s of state.unlocked){
    let valu=state.stats[s];
    let five=BX_mulScalar(valu,0.05);
    let growth = BX_gte(five,BX(1)) ? five : BX(1);
    growth = BX_mul(growth, state.allMult);
    deltas[s]=BX_add(deltas[s],growth);
  }

  /* Higher stats boosting lower */
  for(let i=0;i<state.unlocked.length;i++){
    let low=state.unlocked[i];
    for(let j=i+1;j<state.unlocked.length;j++){
      let high=state.unlocked[j];
      let dist=j-i;
      let hVal=state.stats[high];
      if(hVal.c===0) continue;

      let add = dist<=5 ? BX_mulScalar(hVal,2*dist) : BX_mulScalar(hVal,2);
      add = BX_mul(add,state.allMult);
      deltas[low]=BX_add(deltas[low],add);
    }
  }

  /* Apply deltas */
  for(const s of state.unlocked){
    state.stats[s]=BX_add(state.stats[s],deltas[s]);
  }

  /* Growth ×3 for a */
  let aVal=state.stats.a;
  aVal=BX_mulScalar(aVal,3);

  /* Multipliers */
  aVal=BX_mul(aVal,state.aMultiplierFromTiers);
  state.stats.a=aVal;

  /* ================================================================
     REBIRTH MULTIPLIER: All stats ^ (1.5 ^ rebirths)
     ================================================================ */
  if(state.rebirths > 0){
    const exp = 1.5 ** state.rebirths;
    for(const s of state.unlocked){
      state.stats[s] = BX_pow(state.stats[s], BX(exp));
    }
  }

  /* Auto-complete tier */
  if(state.tierActive && state.currentTier>0){
    let T=state.tiers[state.currentTier-1];
    if(BX_gte(state.stats.a,T.target)){
      completeTier(state.currentTier);
    }
  }

  saveState();
  renderAll();
}

/* ================================================================
   TIERS
   ================================================================ */

function completeTier(n){
  let T=state.tiers[n-1];
  if(!T || T.done) return;
  T.done=true;

  state.tierActive=false;
  state.currentTier=0;
  state.tierDebuffed=false;

  state.aMultiplierFromTiers=BX_mul(state.aMultiplierFromTiers,BX(2));
  state.bMultiplierFromTiers=BX_mul(state.bMultiplierFromTiers,BX(1.5));

  message(`Tier ${n} complete!`);

  if(n===15){
    state.rebirthUnlocked=true;
    state.rebirthFreeAvailable=true;
    state.rebirthCost=BX_clone(T.target);
    message("Tier 15 done — Rebirth unlocked!");
  }

  renderAll();
}

function enterTier(n){
  if(state.tierActive){
    message("Already in a tier","warn");
    return;
  }
  let T=state.tiers[n-1];

  for(const s of state.unlocked){
    state.stats[s]=BX_mulScalar(state.stats[s],0.1);
  }

  state.tierActive=true;
  state.currentTier=n;
  state.tierDebuffed=true;

  message(`Entered Tier ${n}. Goal: a ≥ ${BX_toString(T.target)}`);
  renderAll();
}

/* ================================================================
   REBIRTH
   ================================================================ */

function resetProgressAfterRebirth(){
  state.stats={a:BX(10)};
  state.unlocked=["a"];
  state.allMult=BX(1);
  state.upgradePrice=BX(100);
  state.unlockCost=BX(100);

  state.tiers.forEach(t=>t.done=false);

  state.aMultiplierFromTiers=BX(1);
  state.bMultiplierFromTiers=BX(1);

  state.tierActive=false;
  state.tierDebuffed=false;
  state.currentTier=0;
}

function doRebirth(){
  if(!state.rebirthUnlocked){
    message("Rebirth locked","warn");
    return;
  }

  /* First rebirth free */
  if(state.rebirthFreeAvailable){
    state.rebirthFreeAvailable=false;
    state.rebirths++;
    resetProgressAfterRebirth();
    message("Free rebirth!");
    renderAll();
    return;
  }

  if(!BX_gte(state.stats.a,state.rebirthCost)){
    message(`Need ${BX_toString(state.rebirthCost)} a`,"warn");
    return;
  }

  /* Pay cost */
  state.stats.a = BX_sub(state.stats.a,state.rebirthCost);

  state.rebirths++;

  /* New rebirth cost = old^1.5 */
  state.rebirthCost = BX_pow(state.rebirthCost,1.5);

  resetProgressAfterRebirth();
  message("Rebirth complete!");
  renderAll();
}

/* ================================================================
   UI & BUTTONS
   ================================================================ */

function toXeN(x){ return BX_toString(x); }

const statsBox=document.getElementById("statsBox");
const messageEl=document.getElementById("message");
const aValueEl=document.getElementById("aValue");
const upgradePriceEl=document.getElementById("upgradePrice");
const unlockCostEl=document.getElementById("unlockCost");
const challengeStateEl=document.getElementById("challengeState");
const tierInfoEl=document.getElementById("tierInfo");
const rebirthCountEl=document.getElementById("rebirthCount");
const rebirthCostEl=document.getElementById("rebirthCost");

function renderAll(){
  ensureStats();

  let html="";
  for(const s of state.unlocked){
    html+=`<div class="stat-row">
      <div>${s}</div>
      <div>${toXeN(state.stats[s])}</div>
    </div>`;
  }
  statsBox.innerHTML=html;

  aValueEl.textContent="a: "+toXeN(state.stats.a);
  upgradePriceEl.textContent=toXeN(state.upgradePrice);
  unlockCostEl.textContent=toXeN(state.unlockCost);

  challengeStateEl.textContent=
    state.tierActive?`Tier ${state.currentTier}`:"None";

  let next=state.tiers.find(t=>!t.done);
  tierInfoEl.textContent =
    next ? `Tier ${next.id} → ${toXeN(next.target)}` : "All done";

  rebirthCountEl.textContent=state.rebirths;
  rebirthCostEl.textContent=
    state.rebirthFreeAvailable ? "free" :
    state.rebirthCost ? toXeN(state.rebirthCost) : "locked";
}

let msgTimer=null;
function message(txt,type="ok"){
  messageEl.style.color =
    type==="ok"?"#0f0":type==="warn"?"#fb0":"#f00";
  messageEl.textContent=txt;
  if(msgTimer) clearTimeout(msgTimer);
  msgTimer=setTimeout(()=>messageEl.textContent="",6000);
}

document.getElementById("upgradeBtn").onclick=()=>{
  if(!BX_gte(state.stats.a,state.upgradePrice)){
    message(`Need ${toXeN(state.upgradePrice)}`,"warn");
    return;
  }
  state.stats.a = BX_sub(state.stats.a,state.upgradePrice);
  state.allMult = BX_mulScalar(state.allMult,2);
  state.upgradePrice = BX_mulScalar(state.upgradePrice,10);

  message("Upgrade bought");
  renderAll();
};

document.getElementById("unlockBtn").onclick=()=>{
  if(!BX_gte(state.stats.a,state.unlockCost)){
    message(`Need ${toXeN(state.unlockCost)}`,"warn");
    return;
  }
  state.stats.a = BX_sub(state.stats.a,state.unlockCost);

  let idx = state.unlocked.length+1;
  let label = statLabel(idx);
  state.unlocked.push(label);
  state.stats[label]=BX(10);

  state.unlockCost = BX_mulScalar(state.unlockCost,10);

  message(`Unlocked ${label}`);
  renderAll();
};

document.getElementById("challengeBtn").onclick=()=>{
  let next=state.tiers.find(t=>!t.done);
  if(!next){
    message("No tiers left");
    return;
  }
  enterTier(next.id);
};

document.getElementById("completeBtn").onclick=()=>{
  if(!state.tierActive){
    message("Not in a tier","warn");
    return;
  }
  completeTier(state.currentTier);
};

document.getElementById("rebirthBtn").onclick=()=>{
  doRebirth();
};

/* ================================================================
   SAVE / LOAD
   ================================================================ */

function serializeBX(o){ return {c:o.c,e:o.e}; }
function reviveBX(o){ return {c:o.c,e:o.e}; }

function saveState(){
  try{
    const s=JSON.parse(JSON.stringify(state));

    for(const k of Object.keys(s.stats)){
      s.stats[k]=serializeBX(s.stats[k]);
    }

    s.allMult=serializeBX(s.allMult);
    s.upgradePrice=serializeBX(s.upgradePrice);
    s.unlockCost=serializeBX(s.unlockCost);
    s.aMultiplierFromTiers=serializeBX(s.aMultiplierFromTiers);
    s.bMultiplierFromTiers=serializeBX(s.bMultiplierFromTiers);

    if(s.rebirthCost) s.rebirthCost=serializeBX(s.rebirthCost);

    s.tiers=s.tiers.map(t=>({
      id:t.id,
      done:t.done,
      target:serializeBX(t.target)
    }));

    localStorage.setItem("BIGXEN_GAME",JSON.stringify(s));
  }catch(e){}
}

function loadState(){
  try{
    const raw=localStorage.getItem("BIGXEN_GAME");
    if(!raw) return;
    const s=JSON.parse(raw);

    state.stats={};
    for(const k of Object.keys(s.stats)){
      state.stats[k]=reviveBX(s.stats[k]);
    }

    state.unlocked=s.unlocked;
    state.allMult=reviveBX(s.allMult);
    state.upgradePrice=reviveBX(s.upgradePrice);
    state.unlockCost=reviveBX(s.unlockCost);
    state.aMultiplierFromTiers=reviveBX(s.aMultiplierFromTiers);
    state.bMultiplierFromTiers=reviveBX(s.bMultiplierFromTiers);

    state.rebirths=s.rebirths;
    state.rebirthUnlocked=s.rebirthUnlocked;
    state.rebirthFreeAvailable=s.rebirthFreeAvailable;
    state.rebirthCost=s.rebirthCost?reviveBX(s.rebirthCost):null;

    state.tiers=s.tiers.map(t=>({
      id:t.id,
      done:t.done,
      target:reviveBX(t.target)
    }));

    state.currentTier=s.currentTier;
    state.tierActive=s.tierActive;
    state.tierDebuffed=s.tierDebuffed;

  }catch(e){}
}

/* ================================================================
   BOOT
   ================================================================ */

loadState();
renderAll();
setInterval(doTick,1000);
setInterval(saveState,3000);

</script>

</body>
</html>
